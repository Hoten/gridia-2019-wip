const fs = require("fs");
const ts = require("typescript");

function lowercase(str) {
  return str.charAt(0).toLocaleLowerCase() + str.substr(1);
}

/** @param {ts.Node} node */
function collect(node) {
  const paramsQualifier = ts.createQualifiedName(node.name, "Params");
  const messageParamNodes = getInterfaceDeclarations(node);
  const messageTypes = messageParamNodes.map(messageType => {
    return createMessageType(paramsQualifier, messageType);
  });
  const messageTypesUnion = ts.createTypeAliasDeclaration(
    undefined,
    [ts.createModifier(ts.SyntaxKind.ExportKeyword)],
    "Message",
    undefined,
    ts.createUnionTypeNode(messageTypes.map(type => ts.createTypeReferenceNode(type.name))),
  );
  const messageBuilderFns = messageParamNodes.map((messageParamNode, i) => {
    return createMessageBuilderFn(paramsQualifier, messageParamNode, messageTypes[i]);
  });

  const isServerToClient = node.name.escapedText.includes("ServerToClient"); // :(
  const firstParamType = isServerToClient ? "Client" : "Server";
  const protocolInterface = createProtocolInterface(
    paramsQualifier, "I" + node.name.escapedText, firstParamType, messageParamNodes);

  const autoGenComment = "/* Auto generated by build/build-protocol.js */";
  const builderCode = [
    autoGenComment,
    messageTypes.map(printNode).join("\n"),
    printNode(messageTypesUnion),
    messageBuilderFns.map(printNode).join("\n"),
  ].join("\n\n");
  const protocolInterfaceCode = [
    autoGenComment,
    isServerToClient ? `import Client from '../../client/client'` : `import Server from '../../server/server'`,
    printNode(protocolInterface),
  ].join("\n\n");

  return {
    builderCode,
    protocolInterfaceCode,
  };
}

/**
 * @param {string} prefix
 * @param {ReturnType<typeof collect>}
 */
function save(prefix, code) {
  fs.writeFileSync(`${__dirname}/../src/protocol/gen/${prefix}-protocol-builder.ts`, code.builderCode);
  fs.writeFileSync(`${__dirname}/../src/protocol/gen/${prefix}-protocol.ts`, code.protocolInterfaceCode);
}

/**
 * @param {ts.Node} node
 * @return {ts.Node[]}
 */
function getInterfaceDeclarations(node) {
  const result = [];

  /** @param {ts.Node} n */
  function visit(n) {
    if (n.kind === ts.SyntaxKind.InterfaceDeclaration) {
      result.push(n);
    } else if (ts.isModuleDeclaration(n) || ts.isModuleBlock(n)) {
      ts.forEachChild(n, visit);
    }
  }

  ts.forEachChild(node, visit);
  return result;
}

/**
 * @param {ts.Node} qualifier
 * @param {ts.Node} node
 */
function createMessageType(qualifier, node) {
  /*
    type AdminSetItemMessage = {
      type: "AdminSetItem";
      args: Protocol.Params.AdminSetItem;
    };
  */

  const name = node.name.escapedText;
  const type = ts.createTypeLiteralNode([
    ts.createPropertySignature(
      undefined,
      "type",
      undefined,
      ts.createLiteral(lowercase(name)),
    ),
    ts.createPropertySignature(
      undefined,
      "args",
      undefined,
      ts.createQualifiedName(qualifier, node.name),
    ),
  ]);

  return ts.createTypeAliasDeclaration(
    undefined,
    undefined,
    name + "Message",
    undefined,
    type,
  );
}

/**
 * Create a binding pattern because it makes hover-over IDE signatures more useful
 * when the property names are visibile, as opposed to just "Protocol.Params.Move".
 * @param {ts.Node} qualifier
 * @param {ts.Node} node
 */
function createMessageParamsBinding(qualifier, node) {
  /*
    { item, ...loc }: ClientToServerProtocol.AdminSetItem
  */
  const elements = node.members.map(member => {
    return ts.createBindingElement(
      undefined,
      undefined,
      member.name,
    );
  });

  if (node.heritageClauses) {
    // lol
    const extendedType = printNode(node.heritageClauses[0].types[0]).replace("Partial<", "").replace(">", "");
    let bindName;
    if (extendedType === "TilePoint") {
      bindName = "loc";
    } else if (extendedType === "Creature") {
      bindName = "creature";
    } else {
      throw new Error("unexpected type: " + extendedType);
    }
    elements.push(
      ts.createBindingElement(
        ts.createToken(ts.SyntaxKind.DotDotDotToken),
        undefined,
        bindName,
      ),
    );
  }

  const name = ts.createObjectBindingPattern(elements);
  return ts.createParameter(
    undefined, /* decorators */
    undefined, /* modifiers */
    undefined, /* dotDotDotToken */
    name, /* name */
    undefined, /* questionToken */
    ts.createQualifiedName(qualifier, node.name), /* type */
  );
}

/**
 * @param {ts.Node} qualifier
 * @param {ts.Node} node
 * @param {ts.Node} mesageTypeNode
 */
function createMessageBuilderFn(qualifier, node, mesageTypeNode) {
  /*
    export function adminSetItem({ item, ...loc }: Protocol.Params.AdminSetItem): AdminSetItemMessage {
      return { type: "adminSetItem", args: arguments[0] };
    }
  */

  const lowercasedType = lowercase(node.name.escapedText);
  return ts.createFunctionDeclaration(
    undefined,
    [ts.createModifier(ts.SyntaxKind.ExportKeyword)],
    undefined,
    lowercasedType,
    undefined,
    [createMessageParamsBinding(qualifier, node)],
    mesageTypeNode.name,
    ts.createBlock([
      ts.createReturn(
        ts.createObjectLiteral([
          ts.createPropertyAssignment("type", ts.createLiteral(lowercasedType)),
          // Using arguments is probably faster than making an expression like "{item, ...loc}".
          ts.createPropertyAssignment("args", ts.createElementAccess(ts.createIdentifier("arguments"), 0)),
        ]),
      ),
    ], true),
  );
}

/**
 * @param {ts.Node} qualifier
 * @param {ts.Node} name
 * @param {string} firstParamTypeName
 * @param {ts.Node[]} messageParamNodes
 */
function createProtocolInterface(qualifier, name, firstParamTypeName, messageParamNodes) {
  const members = messageParamNodes.map(messageParamNode => {
    const firstParam = ts.createParameter(
      undefined,
      undefined,
      undefined,
      lowercase(firstParamTypeName),
      undefined,
      ts.createTypeReferenceNode(firstParamTypeName),
    );
    const messageParam = ts.createParameter(
      undefined,
      undefined,
      undefined,
      createMessageParamsBinding(qualifier, messageParamNode),
    );
    return ts.createMethodSignature(
      undefined,
      [firstParam, messageParam],
      ts.createToken(ts.SyntaxKind.VoidKeyword),
      "on" + messageParamNode.name.escapedText,
    );
  });
  return ts.createInterfaceDeclaration(
    undefined, /* decorators */
    [
      ts.createModifier(ts.SyntaxKind.ExportKeyword),
      ts.createModifier(ts.SyntaxKind.DefaultKeyword),
    ], /* modifiers */
    name, /* name */
    undefined, /* typeParameters */
    undefined, /* heritageClauses */
    members, /* members */
  );
}

function printNode(n) {
  const resultFile = ts.createSourceFile(
    "",
    "",
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TS,
  );
  const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
  });
  return printer.printNode(
    ts.EmitHint.Unspecified,
    n,
    resultFile,
  );
}

function findNodeByName(node, name) {
  let result;
  function visit(n) {
    if (n.name && n.name.escapedText === name) {
      result = n;
      return;
    }
    ts.forEachChild(n, visit);
  }
  ts.forEachChild(node, visit);
  if (!result) { throw new Error("did not find " + name); }
  return result;
}

const program = ts.createProgram(["src/protocol/protocol.d.ts"], {
  noEmit: true,
});
const protocolDeclaration = program.getSourceFiles().find(f => f.path.includes("protocol.d.ts"));

if (process.env.DEBUG) {
  const debug = findNodeByName(protocolDeclaration, "debug");
  console.log(debug.members[0]);
  process.exit(0);
}

const clientToServer = collect(findNodeByName(protocolDeclaration, "ClientToServerProtocol"));
const serverToClient = collect(findNodeByName(protocolDeclaration, "ServerToClientProtocol"));

save("client-to-server", clientToServer);
save("server-to-client", serverToClient);
